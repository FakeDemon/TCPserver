# TCP server 

## 0.0

单线程，阻塞IO

## 1.0
基于 C++17 实现单线程事件驱动 TCP Server，采用 Reactor 模型与 epoll 边缘触发 (ET) 处理多客户端连接

## 2.0
引入 Connection 对象和可扩展 Buffer，解决半包/粘包问题

增加了`client.cpp`，提供简单的测试客户端

### 新增特性
- **Connection 管理**：使用 `std::unordered_map<int, Connection>` 管理每个客户端连接的状态
- **双向缓冲区**：每个连接独立的输入(`in`)和输出(`out`)缓冲区，支持动态扩展
- **长度前缀协议**：4 字节网络序长度头 + payload，确保消息完整性
- **半包处理**：缓冲区自动积累数据，直到完整消息到达才处理
- **粘包处理**：循环解析缓冲区，逐条提取完整消息
- **缓冲区压缩**：已读数据超过总大小 50% 时自动清理，避免内存浪费
- **分离读写逻辑**：`handle_read()` 和 `handle_write()` 独立处理，支持非阻塞写回压
- **EPOLLOUT 按需监听**：写缓冲区有数据时才监听 `EPOLLOUT`，减少无效唤醒
- **异常连接清理**：通过 `EPOLLRDHUP` / `EPOLLERR` / `EPOLLHUP` 及时检测并清理异常连接
- **消息大小限制**：64KB 上限，防止恶意超大消息攻击

### 协议格式
```
[4 字节长度(网络序)] + [消息内容]
```

### 核心改进
- 彻底解决 TCP 流式协议的半包/粘包问题

## 2.1
加入信号处理与优雅退出机制，提升系统级稳定性

### 新增特性
- **信号处理**：捕获 `SIGINT` / `SIGTERM` / `SIGHUP` 实现优雅退出
- **屏蔽 SIGPIPE**：忽略 `SIGPIPE`，避免 `send()` 触发进程崩溃
- **运行状态控制**：使用 `std::atomic<bool>` 作为主循环退出标志
- **超时唤醒**：`epoll_wait()` 设置超时，定期检查退出标志
- **退出清理**：退出前统一关闭所有连接并从 epoll 移除

## 3.0

引入多线程工作池，提升并发处理能力

### 新增特性
- **多线程工作池**：使用 `std::thread` 创建多个工作线程，每个线程独立运行一个事件循环
- **连接分配**：主线程接受新连接后，采用轮询方式分配给工作线程处理
- **线程安全事件循环**：每个工作线程维护独立的 epoll 实例和连接管理，避免锁竞争
- **日志增强**：增加线程 ID 和连接信息的日志输出，便于调试和性能分析
- **性能提升**：多线程处理提高了服务器的并发能力，能够更好地利用多核 CPU 资源   

### 压力测试结果（非极限压力）
========== 压测统计结果 ==========
预热请求数: 167754
有效请求数: 6250801
错误统计:
  连接失败: 0
  发送失败: 0
  接收失败: 0
  超时: 0
总错误数: 0
成功率: 100.00%

吞吐量:
  QPS: 208359 req/sec
  带宽(发送): 203.48 MB/s

延迟统计（微秒）:
  最小:          3 us
  平均:         31 us
  P50:          28 us
  P75:          40 us
  P90:          53 us
  P95:          62 us
  P99:          86 us
  P99.9:       269 us
  P99.99:      802 us
  最大:      19343 us

  较为理想的结果，平均延迟在 30 微秒左右，99% 请求在 100 微秒内完成，吞吐量超过 20 万请求每秒，且没有错误发生。